using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Xml.Linq;

namespace ProjectTempalte
{
    // ВНИМАНИЕ! Предлагаемая здесь реализация не является лучшей в своем роде
    // и создана для ознакомления с принципом работы очереди
    public class Queue<T>
    {
        private T[] values; // здесь будут храниться значения
        private int head; // голова, индекс, указывает на начало очереди
        private int tail; // хвост, индекс, указывает на последний элемент очереди
        private int size; // количество элементов в массиве. но не фактических, а "валидных", между head и tail.

        public int Size { get => size; }

        // TODO:
        // Добавить параметр по умолчанию capacity
        // Иницилизировать поля класса в соответствии с принимаемыми аргументами
        public Queue()
        {
        }

        private void FindOrCreateEmptySpace()
        {
            if (head != 0) // Если есть свободное место справа слева
            {
                // TODO:
                // Воспользуйтесь функцией Array.Copy для переноса валидных элементов массива влево.
                // Откуда копируем - values
                // Индекс откуда начинать копировать - head
                // Куда копировать - values
                // Индекс куда начинать копировать - 0
                // Сколько копировать - size
                // Далее обновите значения tail и head


                // В итоге поменяли массив так, что все его валидные элементы находятся в его начале.
                // По сути просто сдвиг элементов влево.
                // Как итог, в конце массива освободилось место
                return;
            }

            // TODO:
            // Измененить размер массива, обновите tail и head
        }

        // TODO:
        // Проверить, что мы можем добавить элемент в массив (проверьте значения tail и values.length)
        // Если нет, вызвать FindOrCreateEmptySpace
        // Добавить элемент и увеличить значение size и tail
        public void Enqueue(T value)
        {
        }

        // TODO:
        // Если размер == 0, выдаем ошибку
        // Запоминаем первый (head) элемент в переменную
        // Если голова находится в конце массива, обнуляем (мы прошли весь массив слева направо, элементов больше нет).
        // Иначе увеличиваем (элементы еще есть)
        // Не забудьте уменьшить размер и вернуть элемент
        public T Dequeue()
        {
            return default(T); // Заглушка
        }

        // TODO:
        // Проверяем размер, выдаем ошибку при нулевом размере
        // Возвращаем элемент
        public T Peek()
        {
            return default(T); // Заглушка
        }

        public bool IsEmpty()
        {
            return true; // TODO: поменять
        }
    }
}
